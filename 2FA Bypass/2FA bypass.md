# 7.2FA bypass

بایپس احراز هویت دو مرحله ای

احراز هویت 2 مرحله ای ناقص یعنی پس از تکمیل لاگین اولیه کاربر, وب سایت به خوبی تایید(verify) نمیکنه که همون کاربر درحال تکمیل مرحله دوم احراز هویت هست, برای مثال لاگین کاربر با مشخصات کاربری عادی خودش در مرحله اول به شرح زیر هست:

```
POST /login-steps/first HTTP/1.1 
Host: vulnerable-website.com 
... 
username=carlos&password=qwerty
```

سپس قبل از رفتن به مرحله دوم فرایند لاگین, یک کوکی مربوط به حسابشون به اونها اختصاص داده میشه:

```
HTTP/1.1 200 OK 
Set-Cookie: account=carlos 

GET /login-steps/second HTTP/1.1 
Cookie: account=carlos
```

موقع وارد کردن کد تایید, ریکوئست از این کوکی استفاده می کنه تا مشخص کنه کاربر به کدوم حساب می خواد دسترسی پیدا کنه:

```
POST /login-steps/second HTTP/1.1 
Host: vulnerable-website.com 
Cookie: account=carlos 
... 
verification-code=123456
```

در این مورد مهاجم میتونه با استفاده از اطلاعات کاربری خودش لاگین کنه, اما بعدش مقدار کوکی حسابشو به هر نام کاربری دلخواهش موقع وارد کردن کد تایید تغییر بده

```
POST /login-steps/second HTTP/1.1 
Host: vulnerable-website.com 
Cookie: account=کاربر-قربانی 
... 
verification-code=123456
```

اسیب پذیری Clickjacking در غیرفعال کردن قابلیت 2FA

تلاش به Iframe کردن صفحه ای کنید که در اون اپلیکیشن به کاربر اجازه میده 2FA رو غیرفعال کنه

اگر Iframe موفقیت امیز بود، سعی کنید یک حمله مهندسی اجتماعی انجام بدید که قربانی رو گول بزنید تا در دام شما بیفته.

دستکاری ریسپانس

ریسپانس, ریکوئست 2FA رو چک کنید

اگر ی همچین چیزی "Success":false دیدید

به "Success":true تغییرش بدید و ببینید 2FA بایپس میشه

دستکاری استاتوس کد

اگر استاتوس کد ریسپانس 4XX مثل 401, 402 و… باشه

استاتوس کد ریسپانس رو به 200 OK تغییر بدید و ببینید 2FA بایپس میشه

قابلیت استفاده مجدد کد 2FA

یک کد 2FA درخواست کنید و ازش استفاده کنید

حالا, دوباره از کد 2FA استفاده کنید و اگر با موفقیت استفاده بشه، این یک مشکل هست

همچنین, درخواست چندین کد 2FA رو امتحان کنید و ببینید که ایا زمانی که کد جدیدی درخواست میشه کدهای درخواستی قبلی منقضی میشند یا نه

همچنین, سعی کنید بعد از مدت زمان طولانی مثلا 1 روز یا بیشتر, دوباره از کد استفاده شده قبلی استفاده کنید. این یک مشکله چون 1 روز برای کرک و حدس زدن یک کد 6 رقمی 2FA کافی هست.

اسیب پذیری CSRF در غیرفعال کردن قابلیت 2FA

دو حساب کاربری ایجاد کنید که اولی اکانت attacker و دومی قربانی باشه
وارد حساب attacker بشید و ریکوئست Disable 2FA رو در برپ کپچر کنید و CSRF poc رو ایجاد(generate) کنید
فایل CSRF poc رو با پسوند HTML ذخیره کنید
حالا وارد حساب قربانی در یک مرورگر دیگ یا تب پرایویت همون مرورگر بشید و فایل CSRF رو اجرا کنید. حالا میتونید ببینید که 2FA رو غیرفعال می کنه که منجر به 2FA Bypass میشه

Backup Code Abuse

از همون تکنیک های مورد استفاده در 2FA مثل دستکاری کد ریسپانس/استاتوس, بروت فورس و.. برای بایپس کدهای پشتیبان(کد هایی هستند که اپلیکیشن در اختیارتون میزاره تا اگر هرموقع با مشکلی برای لاگین کردن مواجه بودید به دادتون برسه) و غیرفعال/ریست کردن 2FA استفاده کنید

Enabling 2FA Doesn't Expire Previous Session

با دو مرورگر مختلف وارد اپلیکیشن بشید و 2FA رو روی اولین session فعال کنید حواستون باشه شما با یک حساب کاربری روی 2 تا مرورگر لاگین کردید و روی اولین مرورگر 2FA رو فعال کردید

از session دوم استفاده کنید که روی همون مرورگر دوم هست اگر بعد از ریلود صفحه session منقضی نشه این یک مشکل هست. در این سناریو اگر یک attacker قبل از 2FA یک session فعال رو دزدیده(hijack) باشه، میتونه تمام قابلیت هارو بدون نیاز به 2FA انجام بده.

-2FA Refer Check Bypass

مستقیما به صفحه ای برید که بعد از 2FA یا هر صفحه authenticate شده دیگه ای از اپلیکیشن میاد

اگر موفق نشدید, هدر refer رو به URL صفحه 2FA تغییر بدید. این ممکنه اپلیکیشن رو فریب بده و وانمود کنه که ریکوئست بعد از سنجیده شدن 2FA اومده

2FA Code Leakage in Response

وقتی دارید درخاست 2FA کد میکنید ریکوئست هارو کپچر کنید و ریسپانسارو چک کنید شاید کد OTP افشا شده باشه

JS File Analysis

موقع درخاست کد 2FA تمام فایل های js ای که در ریسپانس ظاهر میشند رو انالیز کنید و ببینید هر فایل JS حاوی اطلاعاتی هست که بتونه به بایپس کد 2FA کمک کنه.

Lack of Brute-Force Protection

این شامل انواع مسائلیه که تحت security misconfiguration هستند، مثل نبودن rate limit, عدم حفاظت از بروت فورس و…

کد 2FA رو درخاست کنید و ریکوئستشو کپچر کنید

این ریکوئست رو 100-200 بار تکرار کنید و اگر محدودیتی وجود نداشته باشه, این اسیب پذیری rate limit هست

در صفحه تایید کد 2FA، سعی کنید کد 2FA رو بروت فورس کنید تا ببینید کد صحیح رو بدست میارید یا ن (مخصوصا کد 4 یا 5 رقمی باشه =) )

اگر کد OTP های قدیمی اعتبار خودشونو از دست نمیدن و بعد از درخاست چند OTP جدید در یک زمان کدهای اولی هنوز قابل استفاده هستند میتونید هم زمان چندین درخاست کد OTP کنید و هم بروت فورس کنید اینجور شانس بیشتری دارید برای بدست اوردن کد و ممکنه سریع تر هم به نتیجه برسید

[ ] Password Reset/Email Change - 2FA Disable

با فرض اینکه بتونید ایمیل قربانی رو تغییر یا پسوردشو بازیابی کنید یا کاربر قربانی رو به هر طریق ممکن مجبور کنید این کارو بکنه.

احراز هویت 2 مرحله ای بعد تغییر ایمیل یا بازیابی پسورد غیر فعال میشه. این میتونه برای بعضی سازمان ها مشکل ساز باشه. با این حال وابسته به مورد هست.

Missing 2FA Code Integrity Validation

از حساب attacker یک کد 2FA درخاست کنید

این کد معتبر 2FA رو بجای 2FA قربانی که درخاست کرده بودید استفاده کنید و ببینید برای اپلیکیشن قابل تشخیص هست که این کد برای این حساب کاربری مجاز نیست

Direct Request

مستقیما به صفحه ای برید که بعد از 2FA یا هر صفحه authenticate شده دیگه ای از اپلیکیشن میاد

ببینید محدودیت 2FA بایپس میشه

سعی کنید هدر Referrer رو جوری تغییر بدید که انگار از صفحه 2FA اومدید

Reusing token

شاید بشه از توکنی که قبلا استفاده شده در داخل حساب کاربری برای احراز هویت استفاده کنید.

Sharing unused tokens

بررسی کنید میتونید توکنی رو از حساب خودتون بردارید و سعی کنید ازش برای بایپس 2FA در حساب شخص دیگه ای استفاده کنید

Leaked token

آیا توکن در ریسپانس وب اپلیکیشن افشا شده؟

Session permission

با استفاده از session یکسان, روند رو با استفاده از حساب خود و حساب قربانی شروع کنید

وقتی به مرحله 2FA در هر دو حساب رسیدید, 2FA رو با حساب خودتون تکمیل کنید اما به مرحله بعد نرید

به جاش, سعی کنید با حساب قربانی به مرحله بعدی دسترسی پیدا کنید

اگر back-end فقط یک Boolean رو داخل session های شما ست کنه که میگه 2FA رو با موفقیت پشت سر گذاشتید، میتونید 2FA قربانی رو بایپس کنید

Password reset function

تقریبا در همه وب اپلیکیشن ها, عملکرد بازیابی پسورد به طور خودکار کاربرو بعد از تکمیل فرایند بازیابی وارد اپلیکیشن میکنه

بررسی کنید که ایمیل با یک لینک برای بازیابی پسورد ارسال شده یا نه و ایا میتونید چندین بار از اون لینک مجددا برای بازیابی پسورد استفاده کنید هر زمانی که می خواید(حتی اگر قربانی ایمیل خودشو تغییر بده).

Lack of Rate limit

آیا محدودیتی در تعداد کدهایی که میتونید امتحان کنید وجود داره, همینطور میتونید بروت فورسش کنید؟ مراقب rate limit "بی صدا" باشید, همیشه چندین کد و بعدش کد واقعی رو برای تایید اسیب پذیری امتحان کنید

Flow rate limit but no rate limit

در این مورد یک flow rate limit وجود داره(شما باید خیلی اهسته بروت فورسش کنید: یک thread ای (منظور اینه 1 دونه 1 دونه باید اینکارو کنید نه اینکه یهو توی هر ثانیه 10 تا کد بفرستید) و مقداری صبر قبل تلاش بعدی (مثلا هر کدی که میفرستید بسته به اون محدودیت اپلیکیشن ی صبری کنید حالا 2 ثانیه 5 ثانیه یا هرچقدر که اپلیکیشن روش حساس هست) ) اما rate limit وجود نداره. بنابراین با صرف زمان کافی, میتونید کد معتبرو پیدا کنید

Re-send code and reset the limit

مشکل ریت لیمیت وجود داره اما زمانی که شما "کد رو دوباره ارسال می کنید" و کد مشابه ارسال میشه و rate limit ریست میشه. حالا میتونید در حین ارسال مجدد کد, بروت فورسش کنید تا هیچ وقت به rate limit نرسید

[Client side rate limit bypass](https://github.com/Galaxy-sc/vulnerability-Checklist-farsi/blob/main/Rate%20limit/bypass%20rate%20limit.md)

Lack of rate limit in the user's account

بعضی وقتا میتونید 2FA رو برای بعضی از کارها داخل حساب خودتون (تغییر ایمیل, پسورد و...) تنظیم کنید. با این حال حتی در مواردی که در هنگام لاگین کردن rate limit وجود داره. هیچ rate limit ای برای محافظت از موارد داخل حساب وجود نداره

Lack of rate limit re-sending the code via SMS

شما نمیتونید 2FA رو بایپس کنید اما میتونید پول شرکت رو هدر بدید

اگر حساب رو بلاک نمیکنه یا موارد مشابه میتونید هرچقدر دلتون میخاد یا دست کم تعداد زیادی بزنید کد ارسال بشه

Infinite OTP regeneration

اگر بتونید یک OTP جدید رو بی نهایت دفعه تولید کنید, OTP به اندازه کافی ساده باشه مثلا 4 عددی و OTP جدید اجازه امتحان 4 یا 5 بار وارد کردن کدهای اشتباه رو میده, میتونید یکسری کد ثابت انتخاب کنید(حتی میتونید با کشف یک الگوریتم خاص کد های صحیح تر رو انتخاب و اونهارو هربار جایگزین کنید میتونه در بعضی مواقع این کدها برای چندین بار تکراری ارسال بشند پس کار عاقلانه این هست اینجور کد هارو داخل تست هاتون در نظر بگیرید) تا زمانی که اون برای مثال 4 یا 5 کدی که وارد میکنید با کد OTP درست مطابقت پیدا کنه

Guessable cookie

اگر قابلیت "مرا به خاطر بسپار" از یک کوکی جدید با کد قابل حدس استفاده می کنه, سعی کنید حدسش بزنی.

IP address

اگر قابلیت "مرا به خاطر بسپار" به ادرس IP شما وابسته هست, میتونید سعی کنید ادرس IP قربانی رو کشف کنید و با استفاده از هدر **X-Forwarded-For** هویتشو جعل کنید

Subdomains

اگر میتونید ساب دامنه‌های “تستی” که قابلیت لاگین دارند پیدا کنید ممکنه که 2FA نداشته باشند (بنابراین مستقیما بایپس میشه) یا اون endpoint ها میتونند حداقل دارای اسیب‌پذیری 2FA باشند

APIs

اگر متوجه شدید که 2FA از یک API واقع در مسیر /v*/ استفاده می‌کنه (مثل "/v3/"), احتمالا به این معنیه که API endpoint های قدیمی‌ تری وجود داره که ممکنه در برابر نوعی بایپس 2FA اسیب‌پذیر باشند.

Previous sessions

موقعی که 2FA فعاله, session های قبلی ایجاد شده باید منقضی بشند. این به این دلیله که وقتی یک یوزر حسابش به خطر میوفته، میتونه با فعال کردن 2FA ازش محافظت کنه, اما اگر session های قبلی منقضی نشده باشند, این کار ازش محافظت نمیکنه

Improper access control to backup codes

کدهای پشتیبان بلافاصله پس از فعال شدن 2FA ایجاد میشند و با یک درخواست در دسترس هستند. این کدها میتونند تغییر کنند یا ثابت باشند. اگر اسیب پذیری های CORS misconfigurations/XSS و سایر باگ ها وجود داشته باشه, به شما امکان میده از ریسپانس endpoint کد پشتیبان رو بیرون بکشید, attacker میتونه کدها رو بدزده و اگر از نام کاربری و رمز عبور اطلاعی داشته باشه 2FA رو دور بزنه

Information Disclosure

اگر متوجه شدید بعضی اطلاعات محرمانه در صفحه 2FA به چشمتون میخورند که قبلا ازش خبری نداشتید(مثل شماره تلفن), میتونید یک اسیب پذیری information disclosure در نظرش بگیرید

Bypass 2FA with null or 000000

کد 000000 (این کد درواقع یک مثال هست شما میتونید هرچیز دیگه ای بزنید برای مثال 12345 و… همینطور تعداد ارغام مورد قبول 2FA هم در نظر بگیرید) یا null یا یک کد خالی ارسال کنید تا 2FA بایپس بشه

Previously created sessions continue being valid after MFA activation

یک حساب در  [https://account.grammarly.com](https://account.grammarly.com/) بسازید و با 2 مرورگر هم زمان داخلش لاگین کنید
در مرورگر A به [https://account.grammarly.com/security](https://account.grammarly.com/security) برید > تمام مراحل رو برای فعال کردن 2FA تکمیل کنید
حالا 2FA برای این حساب فعال شده
به مرورگر B برید و صفحه رو ریلود کنید session هنوز فعال هست

Enable 2FA without verifying the email I able to add 2FA to my account without verifying my email

سناریوی حمله:

مهاجم با ایمیل قربانی ثبت نام می کنه (تایید ایمیل برای ایمیل قربانی ارسال میشه)
مهاجم قادر به ورود بدون تایید ایمیل هست
مهاجم 2FA رو اضافه میکنه

Password not checked when disabling 2FA

PoC

به اکانت خودتون برید و 2FA رو از /settings/auth فعال کنید

بعد از فعال شدن این گزینه روی ایکون Disabled در کنار تایید هویت دو مرحله ای کلیک کنید

پنجره جدیدی باز میشه که برای تایید غیرفعال شدن Authentication یا Backup کد - پسورد میخاد

در اولین ورودی یک Authentication یا کد Backup معتبر وارد کنید و در فیلد پسورد هر پسورد رندوم/نادرستی رو وارد کنید و روی save کلیک کنید

گزینه بدون بررسی معتبر بودن پسورد با موفقیت غیرفعال میشه

“email” MFA mode allows bypassing MFA from victim’s device when the device trust is not expired

مراحل:

از برپ یا ابزار های دیگ برای intercept ریکوئست ها استفاده کنید

قابلیت MFA(احراز هویت چند عاملی: مثلا نام اخرین معلم یا غذایی که دوست داری و…) حسابتونو روشن و تنظیمش کنید

با ایمیل و پسورد لاگین کنید

صفحه MFA نشون داده میشه

هر عدد تصادفی رو وارد کنید

دکمه “sign in securely” رو فشار بدید و POST ریکوئست `auth.grammarly.com/v3/api/login` رو intercept کنید و فیلد هاشو تغییر بدید: 

"mode":"sms" به رو "mode":"email”

"secureLogin":true به رو "secureLogin":false

تغییرو ارسال کنید و بررسی کنید که در حساب خودتون هستید! نیازی به وارد کردن کد تلفن نبود.

2FA bypass by sending blank code

در Glassdoor لاگین کنید و به [https://www.glassdoor.com/member/account/securitySettings_input.htm](https://www.glassdoor.com/member/account/securitySettings_input.htm) برید

قابلیت 2FA رو فعال کنید

لاگ اوت کنید

دوباره لاگین کنید و ببینید که OTP درخاست شده

حالا با استفاده از برپ POST ریکوئست رو با ارسال کد نادرست intercept کنید[فورواردش نکنید]

قبل از فوروارد ریکوئست به سرور, کد رو حذف و فوروارد کنید

حالا Intercept رو off کنید و ببینید که لاگین شدید